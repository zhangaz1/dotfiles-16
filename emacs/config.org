#+TITLE: Emacs Configuration
#+AUTHOR: Nelson Estevão
#+EMAIL: hello@estevao.xyz
#+OPTIONS: toc:nil num:nil

* =evil-mode=

  I'd prefer not to expand abbrevs when I hit escape. That's always jarring and
  usually not what I want. In particular, it makes working with Coq really
  frustrating.

  #+BEGIN_SRC emacs-lisp
    (setq evil-want-abbrev-expand-on-insert-exit nil)
  #+END_SRC

  Use =evil=.

  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :config
      (evil-mode 1))
  #+END_SRC

  Enable =surround= everywhere.

  #+BEGIN_SRC emacs-lisp
    (use-package evil-surround
      :config
      (global-evil-surround-mode 1))
  #+END_SRC

  Use =evil= with Org agendas.

  #+BEGIN_SRC emacs-lisp
    (use-package evil-org
      :after org
      :config
      (add-hook 'org-mode-hook 'evil-org-mode)
      (add-hook 'evil-org-mode-hook
                (lambda () (evil-org-set-key-theme)))
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))
  #+END_SRC

* UI preferences
** Tweak window chrome

   I don't usually use the menu or scroll bar, and they take up useful space.

   #+BEGIN_SRC emacs-lisp
     (tool-bar-mode 0)
     (menu-bar-mode 0)
     (scroll-bar-mode -1)
   #+END_SRC

   There's a tiny scroll bar that appears in the minibuffer window. This disables
   that:

   #+BEGIN_SRC emacs-lisp
     (set-window-scroll-bars (minibuffer-window) nil nil)
   #+END_SRC

   The default frame title isn't useful. This binds it to the name of the current
   project:

   #+BEGIN_SRC emacs-lisp
     (setq frame-title-format '((:eval (projectile-project-name))))
   #+END_SRC

** Use fancy lambdas

   Why not?

   #+BEGIN_SRC emacs-lisp
     (global-prettify-symbols-mode t)
   #+END_SRC

** Load up a theme

   I'm currently using the "solarized-dark" theme. I've got a scenic wallpaper, so
   just a hint of transparency looks lovely and isn't distracting or hard to read.

   #+BEGIN_SRC emacs-lisp
     (use-package solarized-theme
       :config
       (load-theme 'solarized-dark t)

       (setq solarized-use-variable-pitch nil
             solarized-height-plus-1 1.0
             solarized-height-plus-2 1.0
             solarized-height-plus-3 1.0
             solarized-height-plus-4 1.0)

       (let ((line (face-attribute 'mode-line :underline)))
         (set-face-attribute 'mode-line          nil :overline   line)
         (set-face-attribute 'mode-line-inactive nil :overline   line)
         (set-face-attribute 'mode-line-inactive nil :underline  line)
         (set-face-attribute 'mode-line          nil :box        nil)
         (set-face-attribute 'mode-line-inactive nil :box        nil)
         (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))

     (defun transparency (value)
       "Sets the transparency of the frame window. 0=transparent/100=opaque."
       (interactive "nTransparency Value 0 - 100 opaque:")
       (set-frame-parameter (selected-frame) 'alpha value))

     (defun hrs/apply-theme ()
       "Apply the `solarized-dark' theme and make frames just slightly transparent."
       (interactive)
       (load-theme 'solarized-dark t)
       (transparency 90))
   #+END_SRC

   If this code is being evaluated by =emacs --daemon=, ensure that each subsequent
   frame is themed appropriately.

   #+BEGIN_SRC emacs-lisp
     (if (daemonp)
         (add-hook 'after-make-frame-functions
                   (lambda (frame)
                     (with-selected-frame frame (hrs/apply-theme))))
       (hrs/apply-theme))
   #+END_SRC

** Use =moody= for a beautiful modeline

   This gives me a truly lovely ribbon-based modeline.

   #+BEGIN_SRC emacs-lisp
     (use-package moody
       :config
       (setq x-underline-at-descent-line t)
       (moody-replace-mode-line-buffer-identification)
       (moody-replace-vc-mode))
   #+END_SRC

** Use =minions= to hide all minor modes

   I never want to see a minor mode, and manually adding =:diminish= to every
   use-package declaration is a hassle. This uses =minions= to hide all the minor
   modes in the modeline. Nice!

   By default there's a =;-)= after the major mode; that's an adorable default, but
   I'd rather skip it.

   #+BEGIN_SRC emacs-lisp
     (use-package minions
       :config
       (setq minions-mode-line-lighter ""
             minions-mode-line-delimiters '("" . ""))
       (minions-mode 1))
   #+END_SRC

** Disable visual bell

   =sensible-defaults= replaces the audible bell with a visual one, but I really
   don't even want that (and my Emacs/Mac pair renders it poorly). This disables
   the bell altogether.

   #+BEGIN_SRC emacs-lisp
     (setq ring-bell-function 'ignore)
   #+END_SRC

** Scroll conservatively

   When point goes outside the window, Emacs usually recenters the buffer point.
   I'm not crazy about that. This changes scrolling behavior to only scroll as far
   as point goes.

   #+BEGIN_SRC emacs-lisp
     (setq scroll-conservatively 100)
   #+END_SRC

** Set default font and configure font resizing

   I'm partial to Inconsolata.

   The standard =text-scale-= functions just resize the text in the current buffer;
   I'd generally like to resize the text in /every/ buffer, and I usually want to
   change the size of the modeline, too (this is especially helpful when
   presenting). These functions and bindings let me resize everything all together!

   Note that this overrides the default font-related keybindings from
   =sensible-defaults=.

   #+BEGIN_SRC emacs-lisp
     (setq hrs/default-font "Hack NF")
     (setq hrs/default-font-size 12)
     (setq hrs/current-font-size hrs/default-font-size)

     (setq hrs/font-change-increment 1.1)

     (defun hrs/font-code ()
       "Return a string representing the current font (like \"Inconsolata-14\")."
       (concat hrs/default-font "-" (number-to-string hrs/current-font-size)))

     (defun hrs/set-font-size ()
       "Set the font to `hrs/default-font' at `hrs/current-font-size'.
     Set that for the current frame, and also make it the default for
     other, future frames."
       (let ((font-code (hrs/font-code)))
         (add-to-list 'default-frame-alist (cons 'font font-code))
         (set-frame-font font-code)))

     (defun hrs/reset-font-size ()
       "Change font size back to `hrs/default-font-size'."
       (interactive)
       (setq hrs/current-font-size hrs/default-font-size)
       (hrs/set-font-size))

     (defun hrs/increase-font-size ()
       "Increase current font size by a factor of `hrs/font-change-increment'."
       (interactive)
       (setq hrs/current-font-size
             (ceiling (* hrs/current-font-size hrs/font-change-increment)))
       (hrs/set-font-size))

     (defun hrs/decrease-font-size ()
       "Decrease current font size by a factor of `hrs/font-change-increment', down to a minimum size of 1."
       (interactive)
       (setq hrs/current-font-size
             (max 1
                  (floor (/ hrs/current-font-size hrs/font-change-increment))))
       (hrs/set-font-size))

     (define-key global-map (kbd "C-)") 'hrs/reset-font-size)
     (define-key global-map (kbd "C-+") 'hrs/increase-font-size)
     (define-key global-map (kbd "C-=") 'hrs/increase-font-size)
     (define-key global-map (kbd "C-_") 'hrs/decrease-font-size)
     (define-key global-map (kbd "C--") 'hrs/decrease-font-size)

     (hrs/reset-font-size)
   #+END_SRC

** Highlight the current line

   =global-hl-line-mode= softly highlights the background color of the line
   containing point. It makes it a bit easier to find point, and it's useful when
   pairing or presenting code.

   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode)
   #+END_SRC

** Highlight uncommitted changes

   Use the =diff-hl= package to highlight changed-and-uncommitted lines when
   programming.

   #+BEGIN_SRC emacs-lisp
     (use-package diff-hl
       :config
       (add-hook 'prog-mode-hook 'turn-on-diff-hl-mode)
       (add-hook 'vc-dir-mode-hook 'turn-on-diff-hl-mode))
   #+END_SRC

* Terminal

  I use =multi-term= to manage my shell sessions. It's bound to =C-c t=.

  #+BEGIN_SRC emacs-lisp
    (use-package multi-term)
    (global-set-key (kbd "C-c t") 'multi-term)
  #+END_SRC

  Use a login shell:

  #+BEGIN_SRC emacs-lisp
    (setq multi-term-program-switches "--login")
  #+END_SRC

  I'd rather not use Evil in the terminal. It's not especially useful (I don't use
  vi bindings in xterm) and it shadows useful keybindings (=C-d= for EOF, for
  example).

  #+BEGIN_SRC emacs-lisp
    (evil-set-initial-state 'term-mode 'emacs)
  #+END_SRC

  I add a bunch of hooks to =term-mode=:

  - I'd like links (URLs, etc) to be clickable.
  - Yanking in =term-mode= doesn't quite work. The text from the paste appears in
    the buffer but isn't sent to the shell process. This correctly binds =C-y= and
    middle-click to yank the way we'd expect.
  - I bind =M-o= to quickly change windows. I'd like that in terminals, too.
  - I don't want to perform =yasnippet= expansion when tab-completing.

  #+BEGIN_SRC emacs-lisp
    (defun hrs/term-paste (&optional string)
      (interactive)
      (process-send-string
       (get-buffer-process (current-buffer))
       (if string string (current-kill 0))))

    (add-hook 'term-mode-hook
              (lambda ()
                (goto-address-mode)
                (define-key term-raw-map (kbd "C-y") 'hrs/term-paste)
                (define-key term-raw-map (kbd "<mouse-2>") 'hrs/term-paste)
                (define-key term-raw-map (kbd "M-o") 'other-window)
                (setq yas-dont-activate t)))
  #+END_SRC

* Publishing and task management with Org-mode

  #+BEGIN_SRC emacs-lisp
    (use-package org)
  #+END_SRC

** Display preferences

   I like to see an outline of pretty bullets instead of a list of asterisks.

   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :init
       (add-hook 'org-mode-hook 'org-bullets-mode))
   #+END_SRC

   I like seeing a little downward-pointing arrow instead of the usual ellipsis
   (=...=) that org displays when there's stuff under a header.

   #+BEGIN_SRC emacs-lisp
     (setq org-ellipsis "⤵")
   #+END_SRC

   Use syntax highlighting in source blocks while editing.

   #+BEGIN_SRC emacs-lisp
     (setq org-src-fontify-natively t)
   #+END_SRC

   Make TAB act as if it were issued in a buffer of the language's major mode.

   #+BEGIN_SRC emacs-lisp
     (setq org-src-tab-acts-natively t)
   #+END_SRC

   When editing a code snippet, use the current window rather than popping open a
   new one (which shows the same information).

   #+BEGIN_SRC emacs-lisp
     (setq org-src-window-setup 'current-window)
   #+END_SRC

   Quickly insert a block of elisp:

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-structure-template-alist
                  '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
   #+END_SRC

** Task and org-capture management

   Store my org files in =~/documents/org=, maintain an inbox in Dropbox, define
   the location of an index file (my main todo list), and archive finished tasks in
   =~/documents/org/archive.org=.

   #+BEGIN_SRC emacs-lisp
     (setq org-directory "~/documents/org")

     (defun org-file-path (filename)
       "Return the absolute address of an org file, given its relative name."
       (concat (file-name-as-directory org-directory) filename))

     (setq org-inbox-file "~/Dropbox/inbox.org")
     (setq org-index-file (org-file-path "index.org"))
     (setq org-archive-location
           (concat (org-file-path "archive.org") "::* From %s"))
   #+END_SRC

   I use [[http://agiletortoise.com/drafts/][Drafts]] to create new tasks, format them according to a template, and
   append them to an "inbox.org" file in my Dropbox. This function lets me import
   them easily from that inbox file to my index.

   #+BEGIN_SRC emacs-lisp
     (defun hrs/copy-tasks-from-inbox ()
       (when (file-exists-p org-inbox-file)
         (save-excursion
           (find-file org-index-file)
           (goto-char (point-max))
           (insert-file-contents org-inbox-file)
           (delete-file org-inbox-file))))
   #+END_SRC

   I store all my todos in =~/documents/org/index.org=, so I'd like to derive my
   agenda from there.

   #+BEGIN_SRC emacs-lisp
     (setq org-agenda-files (list org-index-file))
   #+END_SRC

   Hitting =C-c C-x C-s= will mark a todo as done and move it to an appropriate
   place in the archive.

   #+BEGIN_SRC emacs-lisp
     (defun hrs/mark-done-and-archive ()
       "Mark the state of an org-mode item as DONE and archive it."
       (interactive)
       (org-todo 'done)
       (org-archive-subtree))

     (define-key org-mode-map (kbd "C-c C-x C-s") 'hrs/mark-done-and-archive)
   #+END_SRC

   Record the time that a todo was archived.

   #+BEGIN_SRC emacs-lisp
     (setq org-log-done 'time)
   #+END_SRC

**** Capturing tasks

     Define a few common tasks as capture templates. Specifically, I frequently:

     - Record ideas for future blog posts in =~/documents/notes/blog-ideas.org=,
     - Maintain a todo list in =~/documents/org/index.org=.
     - Convert emails into todos to maintain an empty inbox.

     #+BEGIN_SRC emacs-lisp
       (setq org-capture-templates
             '(("b" "Blog idea"
                entry
                (file "~/documents/notes/blog-ideas.org")
                "* %?\n")

               ("e" "Email" entry
                (file+headline org-index-file "Inbox")
                "* TODO %?\n\n%a\n\n")

               ("f" "Finished book"
                table-line (file "~/documents/notes/books-read.org")
                "| %^{Title} | %^{Author} | %u |")

               ("r" "Reading"
                checkitem
                (file (org-file-path "to-read.org")))

               ("s" "Subscribe to an RSS feed"
                plain
                (file "~/documents/rss/urls")
                "%^{Feed URL} \"~%^{Feed name}\"")

               ("t" "Todo"
                entry
                (file+headline org-index-file "Inbox")
                "* TODO %?\n")))
     #+END_SRC

     When I'm starting an Org capture template I'd like to begin in insert mode. I'm
     opening it up in order to start typing something, so this skips a step.

     #+BEGIN_SRC emacs-lisp
       (add-hook 'org-capture-mode-hook 'evil-insert-state)
     #+END_SRC

     Refiling according to the document's hierarchy.

     #+BEGIN_SRC emacs-lisp
       (setq org-refile-use-outline-path t)
       (setq org-outline-path-complete-in-steps nil)
     #+END_SRC

**** Keybindings

     Bind a few handy keys.

     #+BEGIN_SRC emacs-lisp
       (define-key global-map "\C-cl" 'org-store-link)
       (define-key global-map "\C-ca" 'org-agenda)
       (define-key global-map "\C-cc" 'org-capture)
     #+END_SRC

     Hit =C-c i= to quickly open up my todo list.

     #+BEGIN_SRC emacs-lisp
       (defun hrs/open-index-file ()
         "Open the master org TODO list."
         (interactive)
         (hrs/copy-tasks-from-inbox)
         (find-file org-index-file)
         (flycheck-mode -1)
         (end-of-buffer))

       (global-set-key (kbd "C-c i") 'hrs/open-index-file)
     #+END_SRC

     Hit =M-n= to quickly open up a capture template for a new todo.

     #+BEGIN_SRC emacs-lisp
       (defun org-capture-todo ()
         (interactive)
         (org-capture :keys "t"))

       (global-set-key (kbd "M-n") 'org-capture-todo)
       (add-hook 'gfm-mode-hook
                 (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
       (add-hook 'haskell-mode-hook
                 (lambda () (local-set-key (kbd "M-n") 'org-capture-todo)))
     #+END_SRC

** Exporting

   Allow export to markdown and beamer (for presentations).

   #+BEGIN_SRC emacs-lisp
     (require 'ox-md)
     (require 'ox-beamer)
   #+END_SRC

   Allow =babel= to evaluate Emacs lisp, Ruby, dot, or Gnuplot code.

   #+BEGIN_SRC emacs-lisp
     (use-package gnuplot)

     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (ruby . t)
        (dot . t)
        (gnuplot . t)))
   #+END_SRC

   Don't ask before evaluating code blocks.

   #+BEGIN_SRC emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+END_SRC

   Associate the "dot" language with the =graphviz-dot= major mode.

   #+BEGIN_SRC emacs-lisp
     (use-package graphviz-dot-mode)
     (add-to-list 'org-src-lang-modes '("dot" . graphviz-dot))
   #+END_SRC

   Translate regular ol' straight quotes to typographically-correct curly quotes
   when exporting.

   #+BEGIN_SRC emacs-lisp
     (setq org-export-with-smart-quotes t)
   #+END_SRC

**** Exporting to HTML

     Don't include a footer with my contact and publishing information at the bottom
     of every exported HTML document.

     #+BEGIN_SRC emacs-lisp
       (setq org-html-postamble nil)
     #+END_SRC

     Exporting to HTML and opening the results triggers =/usr/bin/sensible-browser=,
     which checks the =$BROWSER= environment variable to choose the right browser.
     I'd like to always use Firefox, so:

     #+BEGIN_SRC emacs-lisp
       (setq browse-url-browser-function 'browse-url-generic
             browse-url-generic-program "firefox")

       (setenv "BROWSER" "firefox")
     #+END_SRC

**** Exporting to PDF

     I want to produce PDFs with syntax highlighting in the code. The best way to do
     that seems to be with the =minted= package, but that package shells out to
     =pygments= to do the actual work. =pdflatex= usually disallows shell commands;
     this enables that.

     #+BEGIN_SRC emacs-lisp
       (setq org-latex-pdf-process
             '("xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
               "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"
               "xelatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
     #+END_SRC

     Include the =minted= package in all of my LaTeX exports.

     #+BEGIN_SRC emacs-lisp
       (add-to-list 'org-latex-packages-alist '("" "minted"))
       (setq org-latex-listings 'minted)
     #+END_SRC


** TeX configuration

   I rarely write LaTeX directly any more, but I often export through it with
   org-mode, so I'm keeping them together.

   Automatically parse the file after loading it.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-parse-self t)
   #+END_SRC

   Always use =pdflatex= when compiling LaTeX documents. I don't really have any
   use for DVIs.

   #+BEGIN_SRC emacs-lisp
     (setq TeX-PDF-mode t)
   #+END_SRC

   Open compiled PDFs in =zathura= instead of in the editor.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'org-mode-hook
               '(lambda ()
                  (delete '("\\.pdf\\'" . default) org-file-apps)
                  (add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s"))))
   #+END_SRC

   Enable a minor mode for dealing with math (it adds a few useful keybindings),
   and always treat the current file as the "main" file. That's intentional, since
   I'm usually actually in an org document.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'LaTeX-mode-hook
               (lambda ()
                 (LaTeX-math-mode)
                 (setq TeX-master t)))
   #+END_SRC

* Writing prose

** Enable spell-checking in the usual places

   I want to make sure that I've enabled spell-checking if I'm editing text,
   composing an email, or authoring a Git commit.

   #+BEGIN_SRC emacs-lisp
     (use-package flyspell
       :config
       (add-hook 'text-mode-hook 'turn-on-auto-fill)
       (add-hook 'gfm-mode-hook 'flyspell-mode)
       (add-hook 'org-mode-hook 'flyspell-mode)

       (add-hook 'git-commit-mode-hook 'flyspell-mode)
       (add-hook 'mu4e-compose-mode-hook 'flyspell-mode))
   #+END_SRC

** Look up definitions in Webster 1913

   I look up definitions by hitting =C-x w=, which shells out to =sdcv=. I've
   loaded that with the (beautifully lyrical) 1913 edition of Webster's dictionary,
   so these definitions are a lot of fun.

   #+BEGIN_SRC emacs-lisp
     (defun hrs/dictionary-prompt ()
       (read-string
        (format "Word (%s): " (or (hrs/region-or-word) ""))
        nil
        nil
        (hrs/region-or-word)))

     (defun hrs/dictionary-define-word ()
       (interactive)
       (let* ((word (hrs/dictionary-prompt))
              (buffer-name (concat "Definition: " word)))
         (with-output-to-temp-buffer buffer-name
           (shell-command (format "sdcv -n %s" word) buffer-name))))

     (define-key global-map (kbd "C-x w") 'hrs/dictionary-define-word)
   #+END_SRC

** Look up words in a thesaurus

   Synosaurus is hooked up to wordnet to provide access to a thesaurus. Hitting
   =C-x s= searches for synonyms.

   #+BEGIN_SRC emacs-lisp
     (use-package synosaurus)
     (setq-default synosaurus-backend 'synosaurus-backend-wordnet)
     (add-hook 'after-init-hook #'synosaurus-mode)
     (define-key global-map "\C-xs" 'synosaurus-lookup)
   #+END_SRC

** Editing with Markdown

   Because I can't always use =org=.

   - Associate =.md= files with GitHub-flavored Markdown.
   - Use =pandoc= to render the results.
   - Leave the code block font unchanged.

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :commands gfm-mode

       :mode (("\\.md$" . gfm-mode))

       :config
       (setq markdown-command "pandoc --standalone --mathjax --from=markdown")
       (custom-set-faces
        '(markdown-code-face ((t nil)))))
   #+END_SRC

** Wrap paragraphs automatically

   =AutoFillMode= automatically wraps paragraphs, kinda like hitting =M-q=. I wrap
   a lot of paragraphs, so this automatically wraps 'em when I'm writing text,
   Markdown, or Org.

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'auto-fill-mode)
     (add-hook 'gfm-mode-hook 'auto-fill-mode)
     (add-hook 'org-mode-hook 'auto-fill-mode)
   #+END_SRC

** Cycle between spacing alternatives

   Successive calls to =cycle-spacing= rotate between changing the whitespace
   around point to:

   - A single space,
   - No spaces, or
   - The original spacing.

   Binding this to =M-SPC= is strictly better than the original binding of
   =just-one-space=.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-SPC") 'cycle-spacing)
   #+END_SRC

** Linting prose

   I use [[http://proselint.com/][proselint]] to check my prose for common errors. This creates a flycheck
   checker that runs proselint in texty buffers and displays my errors.

   #+BEGIN_SRC emacs-lisp
     (require 'flycheck)

     (flycheck-define-checker proselint
       "A linter for prose."
       :command ("proselint" source-inplace)
       :error-patterns
       ((warning line-start (file-name) ":" line ":" column ": "
                 (id (one-or-more (not (any " "))))
                 (message (one-or-more not-newline)
                          (zero-or-more "\n" (any " ") (one-or-more not-newline)))
                 line-end))
       :modes (text-mode markdown-mode gfm-mode org-mode))

     (add-to-list 'flycheck-checkers 'proselint)
   #+END_SRC

   Use flycheck in the appropriate buffers:

   #+BEGIN_SRC emacs-lisp
     (add-hook 'markdown-mode-hook #'flycheck-mode)
     (add-hook 'gfm-mode-hook #'flycheck-mode)
     (add-hook 'text-mode-hook #'flycheck-mode)
     (add-hook 'org-mode-hook #'flycheck-mode)
   #+END_SRC

** Enable region case modification

   #+BEGIN_SRC emacs-lisp
     (put 'downcase-region 'disabled nil)
     (put 'upcase-region 'disabled nil)
   #+END_SRC

** Quickly explore my "notes" directory with =deft=

   #+BEGIN_SRC emacs-lisp
     (use-package deft
       :bind ("C-c n" . deft)
       :commands (deft)
       :config

       (setq deft-directory "~/documents/notes"
             deft-recursive t
             deft-use-filename-as-title t)

       (evil-set-initial-state 'deft-mode 'emacs))
   #+END_SRC

* =dired=

  Hide dotfiles by default, but toggle their visibility with =.=.

  #+BEGIN_SRC emacs-lisp
    (use-package dired-hide-dotfiles
      :config
      (dired-hide-dotfiles-mode)
      (define-key dired-mode-map "." 'dired-hide-dotfiles-mode))
  #+END_SRC

  Open media with the appropriate programs.

  #+BEGIN_SRC emacs-lisp
    (use-package dired-open
      :config
      (setq dired-open-extensions
            '(("pdf" . "zathura")
              ("mkv" . "vlc")
              ("mp3" . "vlc")
              ("mp4" . "vlc")
              ("avi" . "vlc"))))
  #+END_SRC

  These are the switches that get passed to =ls= when =dired= gets a list of
  files. We're using:

  - =l=: Use the long listing format.
  - =h=: Use human-readable sizes.
  - =v=: Sort numbers naturally.
  - =A=: Almost all. Doesn't include "=.=" or "=..=".

  #+BEGIN_SRC emacs-lisp
    (setq-default dired-listing-switches "-lhvA")
  #+END_SRC

  Use "j" and "k" to move around in =dired=.

  #+BEGIN_SRC emacs-lisp
    (evil-define-key 'normal dired-mode-map (kbd "j") 'dired-next-line)
    (evil-define-key 'normal dired-mode-map (kbd "k") 'dired-previous-line)
  #+END_SRC

  Kill buffers of files/directories that are deleted in =dired=.

  #+BEGIN_SRC emacs-lisp
    (setq dired-clean-up-buffers-too t)
  #+END_SRC

  Always copy directories recursively instead of asking every time.

  #+BEGIN_SRC emacs-lisp
    (setq dired-recursive-copies 'always)
  #+END_SRC

  Ask before recursively /deleting/ a directory, though.

  #+BEGIN_SRC emacs-lisp
    (setq dired-recursive-deletes 'top)
  #+END_SRC

  Open a file with an external program (that is, through =xdg-open=) by hitting
  =C-c C-o=.

  #+BEGIN_SRC emacs-lisp
    (defun dired-xdg-open ()
      "In dired, open the file named on this line."
      (interactive)
      (let* ((file (dired-get-filename nil t)))
        (call-process "xdg-open" nil 0 nil file)))

    (define-key dired-mode-map (kbd "C-c C-o") 'dired-xdg-open)
  #+END_SRC

* Editing settings

** Quickly visit Emacs configuration

   I futz around with my dotfiles a lot. This binds =C-c e= to quickly open my
   Emacs configuration file.

   #+BEGIN_SRC emacs-lisp
     (defun hrs/visit-emacs-config ()
       (interactive)
       (find-file "~/.dotfiles/emacs/config.org"))

     (global-set-key (kbd "C-c e") 'hrs/visit-emacs-config)
   #+END_SRC

** Always kill current buffer

   Assume that I always want to kill the current buffer when hitting =C-x k=.

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x k") 'hrs/kill-current-buffer)
   #+END_SRC

** Save my location within a file

   Using =save-place-mode= saves the location of point for every file I visit. If I
   close the file or close the editor, then later re-open it, point will be at the
   last place I visited.

   #+BEGIN_SRC emacs-lisp
     (save-place-mode t)
   #+END_SRC

** Always indent with spaces

   Never use tabs. Tabs are the devil’s whitespace.

   #+BEGIN_SRC emacs-lisp
     (setq-default indent-tabs-mode nil)
   #+END_SRC

** Install and configure =which-key=

   =which-key= displays the possible completions for a long keybinding. That's
   really helpful for some modes (like =projectile=, for example).

   #+BEGIN_SRC emacs-lisp
     (use-package which-key
       :config (which-key-mode))
   #+END_SRC

** Configure =ivy= and =counsel=

   I use =ivy= and =counsel= as my completion framework.

   This configuration:

   - Uses =counsel-M-x= for command completion,
   - Replaces =isearch= with =swiper=,
   - Uses =smex= to maintain history,
   - Enables fuzzy matching everywhere except swiper (where it's thoroughly
     unhelpful), and
   - Includes recent files in the switch buffer.

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :bind
       ("M-x" . 'counsel-M-x)
       ("C-s" . 'swiper)

       :config
       (use-package flx)
       (use-package smex)

       (ivy-mode 1)
       (setq ivy-use-virtual-buffers t)
       (setq ivy-count-format "(%d/%d) ")
       (setq ivy-initial-inputs-alist nil)
       (setq ivy-re-builders-alist
             '((swiper . ivy--regex-plus)
               (t . ivy--regex-fuzzy))))
   #+END_SRC

** Switch and rebalance windows when splitting

   When splitting a window, I invariably want to switch to the new window. This
   makes that automatic.

   #+BEGIN_SRC emacs-lisp
     (defun hrs/split-window-below-and-switch ()
       "Split the window horizontally, then switch to the new pane."
       (interactive)
       (split-window-below)
       (balance-windows)
       (other-window 1))

     (defun hrs/split-window-right-and-switch ()
       "Split the window vertically, then switch to the new pane."
       (interactive)
       (split-window-right)
       (balance-windows)
       (other-window 1))

     (global-set-key (kbd "C-x 2") 'hrs/split-window-below-and-switch)
     (global-set-key (kbd "C-x 3") 'hrs/split-window-right-and-switch)
   #+END_SRC

** Mass editing of =grep= results

   I like the idea of mass editing =grep= results the same way I can edit filenames
   in =dired=. These keybindings allow me to use =C-x C-q= to start editing =grep=
   results and =C-c C-c= to stop, just like in =dired=.

   #+BEGIN_SRC emacs-lisp
     (use-package wgrep)

     (eval-after-load 'grep
       '(define-key grep-mode-map
          (kbd "C-x C-q") 'wgrep-change-to-wgrep-mode))

     (eval-after-load 'wgrep
       '(define-key grep-mode-map
          (kbd "C-c C-c") 'wgrep-finish-edit))

     (setq wgrep-auto-save-buffer t)
   #+END_SRC

** Use projectile everywhere

   #+BEGIN_SRC emacs-lisp
     (projectile-global-mode)
   #+END_SRC

** Add a bunch of engines for =engine-mode=

   Enable [[https://github.com/hrs/engine-mode][engine-mode]] and define a few useful engines.

   #+BEGIN_SRC emacs-lisp
     (use-package engine-mode)
     (require 'engine-mode)

     (defengine duckduckgo
       "https://duckduckgo.com/?q=%s"
       :keybinding "d")

     (defengine github
       "https://github.com/search?ref=simplesearch&q=%s"
       :keybinding "g")

     (defengine google
       "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s")

     (defengine rfcs
       "http://pretty-rfc.herokuapp.com/search?q=%s")

     (defengine stack-overflow
       "https://stackoverflow.com/search?q=%s"
       :keybinding "s")

     (defengine wikipedia
       "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
       :keybinding "w")

     (defengine wiktionary
       "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

     (defengine youtube
       "https://www.youtube.com/results?search_query=%s")

     (engine-mode t)
   #+END_SRC

* Set custom keybindings

  Just a few handy functions.

  #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "C-w") 'backward-kill-word)
    (global-set-key (kbd "M-o") 'other-window)
  #+END_SRC

  Remap when working in terminal Emacs.

  #+BEGIN_SRC emacs-lisp
    (define-key input-decode-map "\e[1;2A" [S-up])
  #+END_SRC
